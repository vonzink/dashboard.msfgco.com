<!DOCTYPE html>
<html>
<head>
  <script src="/js/auth-gate.js?v=20260227-1"></script>
  <meta charset="utf-8" />
  <title>MSFG Company Calendar</title>

  <link rel="stylesheet" href="styles.css">

  <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.js"></script>
</head>

<body class="calendarPage">
  <div id="calToast" class="cal-toast"></div>

  <div class="pageHeader">
    <h2>MSFG Team Calendar</h2>
  </div>

  <div id="calendarWrap">
    <div id="calendar"></div>
  </div>

  <!-- Floating draggable data panel -->
  <div id="eventPanel" class="floating-panel" style="display:none;">
    <div class="panelHeader" id="panelDragHandle">
      <h3 id="modalTitle">Add Event</h3>
      <button class="closeX" id="btnX" title="Close">&#10005;</button>
    </div>

    <label>Title
      <input id="f_title" placeholder="Vacation / Out / Big Event" />
    </label>

    <label>Who
      <input id="f_who" placeholder="Name" />
    </label>

    <label>Start
      <input id="f_start" type="datetime-local" />
    </label>

    <label>End
      <input id="f_end" type="datetime-local" />
    </label>

    <label>Color
      <div class="color-picker-row" id="colorPicker">
        <button type="button" class="color-swatch" data-color="#104547" title="Teal (default)"></button>
        <button type="button" class="color-swatch" data-color="#8cc63E" title="Green"></button>
        <button type="button" class="color-swatch" data-color="#2563eb" title="Blue"></button>
        <button type="button" class="color-swatch" data-color="#7c3aed" title="Purple"></button>
        <button type="button" class="color-swatch" data-color="#dc2626" title="Red"></button>
        <button type="button" class="color-swatch" data-color="#ea580c" title="Orange"></button>
        <button type="button" class="color-swatch" data-color="#0891b2" title="Cyan"></button>
        <button type="button" class="color-swatch" data-color="#404041" title="Dark Gray"></button>
      </div>
      <input id="f_color" type="hidden" value="#104547" />
    </label>

    <label id="recurrenceLabel">Repeat
      <select id="f_recurrence">
        <option value="none">None</option>
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="biweekly">Every 2 Weeks</option>
        <option value="monthly">Monthly</option>
        <option value="yearly">Yearly</option>
      </select>
    </label>

    <label id="recurrenceEndWrap" style="display:none;">Repeat Until
      <input id="f_recurrence_end" type="date" />
    </label>

    <label>Notes
      <textarea id="f_notes" rows="3" placeholder="Any details..."></textarea>
    </label>

    <div class="actions">
      <button id="btnDelete" style="display:none;">Delete</button>
      <button id="btnCancel">Cancel</button>
      <button id="btnSave">Save</button>
    </div>
  </div>

  <!-- Series scope dialog -->
  <div id="scopeDialog" class="scope-overlay" style="display:none;">
    <div class="scope-box">
      <h4 id="scopeTitle">Edit recurring event</h4>
      <button class="scope-btn" id="scopeSingle">This event only</button>
      <button class="scope-btn" id="scopeAll">All events in series</button>
      <button class="scope-btn scope-cancel" id="scopeCancel">Cancel</button>
    </div>
  </div>

  <script>
    /* ── Dashboard API integration ── */
    const API_BASE = window.location.protocol === 'https:'
      ? 'https://api.msfgco.com/api'
      : 'http://54.175.238.145:8080/api';

    function getAuthToken() {
      const cookieMatch = document.cookie.match(/(?:^|;\s*)auth_token=([^;]*)/);
      return (
        localStorage.getItem('auth_token') ||
        (cookieMatch ? decodeURIComponent(cookieMatch[1]) : null) ||
        sessionStorage.getItem('auth_token')
      );
    }

    async function api(path, opts = {}) {
      const token = getAuthToken();
      const headers = { 'Content-Type': 'application/json', ...opts.headers };
      if (token) headers['Authorization'] = 'Bearer ' + token;

      const res = await fetch(API_BASE + path, { ...opts, headers });
      if (res.status === 401) {
        throw new Error('Session expired. Please log in again.');
      }
      if (res.status === 403) {
        const body = await res.json().catch(function() { return {}; });
        throw new Error(body.error || 'You do not have permission to perform this action.');
      }
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || 'Request failed');
      }
      return res.json();
    }

    function toLocalInputValue(date) {
      if (!date) return '';
      const pad = n => String(n).padStart(2, '0');
      const d = new Date(date);
      return d.getFullYear() + '-' + pad(d.getMonth()+1) + '-' + pad(d.getDate()) + 'T' + pad(d.getHours()) + ':' + pad(d.getMinutes());
    }

    /* ── Toast notification ── */
    function showToast(msg, type) {
      var el = document.getElementById('calToast');
      if (!el) return alert(msg);
      el.textContent = msg;
      el.className = 'cal-toast cal-toast-' + (type || 'info') + ' cal-toast-show';
      clearTimeout(el._tid);
      el._tid = setTimeout(function() { el.classList.remove('cal-toast-show'); }, 4000);
    }

    document.addEventListener('DOMContentLoaded', async function () {
      const panel      = document.getElementById('eventPanel');
      const modalTitle = document.getElementById('modalTitle');
      const fTitle     = document.getElementById('f_title');
      const fWho       = document.getElementById('f_who');
      const fStart     = document.getElementById('f_start');
      const fEnd       = document.getElementById('f_end');
      const fNotes     = document.getElementById('f_notes');
      const fColor     = document.getElementById('f_color');
      const colorPicker = document.getElementById('colorPicker');
      const fRecurrence = document.getElementById('f_recurrence');
      const fRecurrenceEnd = document.getElementById('f_recurrence_end');
      const recurrenceLabel = document.getElementById('recurrenceLabel');
      const recurrenceEndWrap = document.getElementById('recurrenceEndWrap');
      const btnSave    = document.getElementById('btnSave');
      const btnCancel  = document.getElementById('btnCancel');
      const btnDelete  = document.getElementById('btnDelete');
      const btnX       = document.getElementById('btnX');

      // Scope dialog
      const scopeDialog = document.getElementById('scopeDialog');
      const scopeTitle  = document.getElementById('scopeTitle');
      const scopeSingle = document.getElementById('scopeSingle');
      const scopeAll    = document.getElementById('scopeAll');
      const scopeCancel = document.getElementById('scopeCancel');

      /* ── Current user (for RBAC) ── */
      var currentUser = { id: null, role: 'user' };
      try {
        var me = await api('/me');
        if (me) {
          currentUser.id = me.id;
          currentUser.role = (me.role || 'user').toLowerCase();
        }
      } catch (e) {
        console.warn('Could not load current user:', e.message);
      }

      function canEditEvent(event) {
        if (currentUser.role === 'admin') return true;
        var createdBy = event.extendedProps ? event.extendedProps.created_by : null;
        return createdBy === currentUser.id;
      }

      /* ── Color picker ── */
      function setActiveColor(hex) {
        fColor.value = hex;
        colorPicker.querySelectorAll('.color-swatch').forEach(function(s) {
          s.classList.toggle('active', s.dataset.color === hex);
        });
      }
      colorPicker.addEventListener('click', function(e) {
        var swatch = e.target.closest('.color-swatch');
        if (swatch) setActiveColor(swatch.dataset.color);
      });
      setActiveColor('#104547');

      /* ── Recurrence toggle ── */
      fRecurrence.addEventListener('change', function() {
        recurrenceEndWrap.style.display = fRecurrence.value === 'none' ? 'none' : 'block';
      });

      /* ── Draggable floating panel ── */
      const handle = document.getElementById('panelDragHandle');
      let isDragging = false, dragOffsetX = 0, dragOffsetY = 0;

      handle.addEventListener('mousedown', function(e) {
        if (e.target.closest('.closeX')) return;
        isDragging = true;
        const rect = panel.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        handle.style.cursor = 'grabbing';
        e.preventDefault();
      });

      document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        const x = Math.max(0, Math.min(e.clientX - dragOffsetX, window.innerWidth - panel.offsetWidth));
        const y = Math.max(0, Math.min(e.clientY - dragOffsetY, window.innerHeight - panel.offsetHeight));
        panel.style.left = x + 'px';
        panel.style.top  = y + 'px';
        panel.style.right = 'auto';
      });

      document.addEventListener('mouseup', function() {
        isDragging = false;
        handle.style.cursor = 'grab';
      });

      /* ── Open / Close ── */
      function openPanel() {
        panel.style.display = 'block';
        if (!panel.style.left || panel.style.left === 'auto') {
          panel.style.top   = '120px';
          panel.style.right = '32px';
          panel.style.left  = 'auto';
        }
      }
      function closePanel() { panel.style.display = 'none'; }

      btnCancel.onclick = closePanel;
      btnX.onclick = closePanel;

      let editingEvent = null;

      function primeFormForCreate(startDate, endDate) {
        editingEvent = null;
        btnDelete.style.display = 'none';
        btnSave.style.display = 'inline-block';
        modalTitle.textContent = 'Add Event';
        fTitle.value = '';
        fWho.value   = '';
        fNotes.value = '';
        fStart.value = toLocalInputValue(startDate);
        fEnd.value   = toLocalInputValue(endDate);
        setActiveColor('#104547');
        fRecurrence.value = 'none';
        fRecurrenceEnd.value = '';
        recurrenceLabel.style.display = 'block';
        recurrenceEndWrap.style.display = 'none';
        setFormEditable(true);
      }

      function primeFormForEdit(event) {
        editingEvent = event;
        var editable = canEditEvent(event);
        modalTitle.textContent = editable ? 'Edit Event' : 'View Event';
        btnDelete.style.display = editable ? 'inline-block' : 'none';
        btnSave.style.display = editable ? 'inline-block' : 'none';
        fTitle.value = event.title || '';
        fWho.value   = event.extendedProps.who || '';
        fNotes.value = event.extendedProps.notes || '';
        fStart.value = toLocalInputValue(event.start);
        fEnd.value   = toLocalInputValue(event.end);
        setActiveColor(event.extendedProps.color || '#104547');
        // Hide recurrence when editing — can't change recurrence pattern
        fRecurrence.value = 'none';
        fRecurrenceEnd.value = '';
        recurrenceLabel.style.display = 'none';
        recurrenceEndWrap.style.display = 'none';
        setFormEditable(editable);
      }

      function setFormEditable(editable) {
        fTitle.readOnly = !editable;
        fWho.readOnly = !editable;
        fStart.readOnly = !editable;
        fEnd.readOnly = !editable;
        fNotes.readOnly = !editable;
        colorPicker.style.pointerEvents = editable ? '' : 'none';
        colorPicker.style.opacity = editable ? '' : '0.5';
      }

      /* ── Scope dialog ── */
      function askScope(title) {
        return new Promise(function(resolve) {
          scopeTitle.textContent = title;
          scopeDialog.style.display = 'flex';
          function cleanup() {
            scopeDialog.style.display = 'none';
            scopeSingle.onclick = null;
            scopeAll.onclick = null;
            scopeCancel.onclick = null;
          }
          scopeSingle.onclick = function() { cleanup(); resolve('single'); };
          scopeAll.onclick    = function() { cleanup(); resolve('all'); };
          scopeCancel.onclick = function() { cleanup(); resolve(null); };
        });
      }

      /* ── FullCalendar ── */
      var calendar = new FullCalendar.Calendar(document.getElementById('calendar'), {
        headerToolbar: {
          left: 'prev,next today',
          center: 'title',
          right: 'dayGridMonth,timeGridWeek,timeGridDay'
        },
        initialView: 'timeGridWeek',
        selectable: true,
        editable: true,
        eventStartEditable: true,
        eventDurationEditable: true,
        dragScroll: true,

        dateClick: function(info) {
          var start = info.date;
          var end = new Date(start.getTime() + 60 * 60 * 1000);
          primeFormForCreate(start, end);
          openPanel();
        },

        select: function(selectionInfo) {
          primeFormForCreate(selectionInfo.start, selectionInfo.end);
          openPanel();
          calendar.unselect();
        },

        events: async function(info, success, failure) {
          try {
            var rows = await api('/calendar-events');
            success(rows.map(function(r) {
              var c = r.color || '#104547';
              return {
                id: String(r.id),
                title: r.title,
                start: r.start,
                end: r.end,
                allDay: !!r.allDay,
                backgroundColor: c,
                borderColor: c,
                extendedProps: {
                  who: r.who || '',
                  notes: r.notes || '',
                  color: c,
                  recurrence_group_id: r.recurrence_group_id || null,
                  recurrence_rule: r.recurrence_rule || 'none',
                  created_by: r.created_by
                }
              };
            }));
          } catch (e) {
            console.error('Failed to load events:', e);
            failure(e);
          }
        },

        eventClick: function(info) {
          primeFormForEdit(info.event);
          openPanel();
        },

        /* Allow drag-drop only for owned events */
        eventAllow: function(dropInfo, draggedEvent) {
          return canEditEvent(draggedEvent);
        },

        eventChange: async function(changeInfo) {
          var e = changeInfo.event;
          try {
            await api('/calendar-events/' + e.id, {
              method: 'PUT',
              body: JSON.stringify({
                title: e.title,
                who: e.extendedProps.who || '',
                notes: e.extendedProps.notes || '',
                start: e.start.toISOString(),
                end: e.end ? e.end.toISOString() : null,
                allDay: e.allDay,
                color: e.extendedProps.color || '#104547'
              })
            });
          } catch (err) {
            showToast(err.message, 'error');
            changeInfo.revert();
          }
        },

        eventContent: function(arg) {
          var who = arg.event.extendedProps.who;
          var isRecurring = arg.event.extendedProps.recurrence_group_id;
          var title = who ? arg.event.title + ' \u2014 ' + who : arg.event.title;
          var icon = isRecurring ? '<span class="recur-icon">\u21BB</span> ' : '';
          return { html: icon + '<span>' + title + '</span>' };
        }
      });

      /* ── Save ── */
      btnSave.onclick = async function() {
        var payload = {
          title: fTitle.value.trim(),
          who:   fWho.value.trim(),
          start: fStart.value ? new Date(fStart.value).toISOString() : null,
          end:   fEnd.value   ? new Date(fEnd.value).toISOString()   : null,
          allDay: false,
          notes: fNotes.value.trim(),
          color: fColor.value || '#104547'
        };

        if (!payload.title || !payload.start) {
          showToast('Title and Start are required.', 'error');
          return;
        }

        try {
          if (!editingEvent) {
            // New event
            var rule = fRecurrence.value;
            if (rule !== 'none') {
              if (!fRecurrenceEnd.value) {
                showToast('Please set a "Repeat Until" date.', 'error');
                return;
              }
              payload.recurrence_rule = rule;
              payload.recurrence_end = fRecurrenceEnd.value;
            }

            await api('/calendar-events', { method: 'POST', body: JSON.stringify(payload) });
            calendar.refetchEvents();
          } else {
            // Edit existing
            var groupId = editingEvent.extendedProps.recurrence_group_id;
            var scope = 'single';

            if (groupId) {
              scope = await askScope('Edit recurring event');
              if (!scope) return;
            }

            await api('/calendar-events/' + editingEvent.id + '?scope=' + scope, {
              method: 'PUT',
              body: JSON.stringify(payload)
            });

            if (scope === 'all') {
              calendar.refetchEvents();
            } else {
              editingEvent.setProp('title', payload.title);
              editingEvent.setStart(payload.start);
              editingEvent.setEnd(payload.end);
              editingEvent.setProp('backgroundColor', payload.color);
              editingEvent.setProp('borderColor', payload.color);
              editingEvent.setExtendedProp('who', payload.who);
              editingEvent.setExtendedProp('notes', payload.notes);
              editingEvent.setExtendedProp('color', payload.color);
            }
          }

          closePanel();
          showToast('Event saved.', 'success');
        } catch (err) {
          console.error('Save failed:', err);
          showToast(err.message, 'error');
        }
      };

      /* ── Delete ── */
      btnDelete.onclick = async function() {
        if (!editingEvent) return;

        var groupId = editingEvent.extendedProps.recurrence_group_id;
        var scope = 'single';

        if (groupId) {
          scope = await askScope('Delete recurring event');
          if (!scope) return;
        } else {
          if (!confirm('Delete this event?')) return;
        }

        try {
          await api('/calendar-events/' + editingEvent.id + '?scope=' + scope, { method: 'DELETE' });

          if (scope === 'all') {
            calendar.refetchEvents();
          } else {
            editingEvent.remove();
          }

          closePanel();
          showToast('Event deleted.', 'success');
        } catch (err) {
          console.error('Delete failed:', err);
          showToast(err.message, 'error');
        }
      };

      calendar.render();
    });
  </script>
</body>
</html>
